============================================================
Project Root: /Users/jake/llmify
Generated At: 2025-03-28T22:23:21-04:00
============================================================

## File Tree Structure

```
llmify/
‚îú‚îÄ‚îÄ .git/
‚îú‚îÄ‚îÄ bin/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ commit.go
‚îú‚îÄ‚îÄ dist/
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.go
‚îÇ   ‚îú‚îÄ‚îÄ git/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ git.go
‚îÇ   ‚îú‚îÄ‚îÄ llm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ openai.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ prompts.go
‚îÇ   ‚îî‚îÄ‚îÄ ui/
‚îÇ       ‚îî‚îÄ‚îÄ editor.go
‚îú‚îÄ‚îÄ npm/
‚îÇ   ‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îú‚îÄ‚îÄ .npmignore
‚îÇ   ‚îú‚îÄ‚îÄ cli.js
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ build.sh
‚îÇ   ‚îú‚îÄ‚îÄ deploy.sh
‚îÇ   ‚îú‚îÄ‚îÄ install.sh
‚îÇ   ‚îú‚îÄ‚îÄ quickstart.sh
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ .llmifyrc.yaml
‚îú‚îÄ‚îÄ .llmignore
‚îú‚îÄ‚îÄ build-binaries.sh
‚îú‚îÄ‚îÄ CHANGELOG.md
‚îú‚îÄ‚îÄ crawler.go
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ tree.go
‚îî‚îÄ‚îÄ utils.go
```

============================================================

## File Contents

### File: .gitignore

```gitignore
# Build artifacts
# Note: All build and deployment scripts (*.sh, *.bat, etc.) are intentionally NOT ignored
/bin/
/dist/
/llmify
/llmify-*
*.exe
*.out

# Go specific
*.dll
*.so
*.dylib
*.test
go.work

# npm directory
npm/node_modules/
npm/coverage/
npm/dist/

# Editor and OS files
.idea/
.vscode/*
!.vscode/extensions.json
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
.DS_Store
Thumbs.db
*.swp
*.swo

# Logs and debug
*.log
npm-debug.log*

# Environment and secrets
.env
.env.*

# Test files that shouldn't be included in version control
/testdata/
/tmp/
*.tmp 
```

---

### File: .llmifyrc.yaml

```yaml
# LLM Configuration
llm:
  # The LLM provider to use (e.g., "openai", "anthropic", "ollama")
  provider: "openai"
  
  # The default model to use for general tasks
  model: "gpt-4o-mini"
  
  # Provider-specific settings
  ollama_base_url: "http://localhost:11434"  # Only used for Ollama provider

# Commit-specific settings
commit:
  # Optional: Override the default model for commit message generation
  # If not set, uses the default model from llm.model
  model: "gpt-4o-mini"

# Documentation update settings
docs:
  # Optional: Override the default model for documentation updates
  # If not set, uses the default model from llm.model
  model: "gpt-4o"
  # TODO: Add patterns for doc files to check
  # patterns: ["*.md", "docs/**/*.md"] 
```

---

### File: .llmignore

```llmignore
# Default .llmignore created by llmify
# Add or remove patterns as needed

# Package lock files (large, machine-generated)
package-lock.json
yarn.lock
pnpm-lock.yaml
composer.lock
Cargo.lock
Gemfile.lock
go.sum

# Build output and artifacts
dist/
build/
coverage/
*.min.js
*.min.css

# Large data files
*.csv
*.xlsx
*.parquet
*.sql
*.db
*.sqlite

# Images and media (binary content)
*.jpg
*.jpeg
*.png
*.gif
*.ico
*.svg
*.webp

# Generated or compiled content
**/*.map
**/__pycache__/
**/.pytest_cache/
**/.next/
**/.nuxt/

# Machine-specific configuration
.DS_Store
Thumbs.db
.env.local
.idea/
.vscode/
*.swp
*.swo

```

---

### File: CHANGELOG.md

```md
# Changelog

## v0.0.7 (2025-03-29)

- Add `llmify commit` command for AI-powered commit message generation
- Add support for automatic documentation updates with `--docs` flag
- Add configuration system with `.llmifyrc.yaml` and environment variables
- Add support for multiple LLM providers (OpenAI, Anthropic, Ollama)
- Add global flags for verbose output and LLM timeout
- Improve error handling and user feedback

## v0.0.6 (2025-03-26)

- update binaries


## v0.0.5 (2025-03-26)

- npm readme


## v0.0.4 (2025-03-26)

- update readme


## v0.0.3 (2025-03-26)

- add intelligent defaults


## v0.0.2 (2025-03-26)

- add dummy build script
- initial release



```

---

### File: LICENSE

```
MIT License

Copyright (c) 2023-2024 Your Name or Organization

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. 
```

---

### File: README.md

```md
# üöÄ LLMify

> **A collection of tools that optimize your codebase for LLMs and agents**

[![npm version](https://img.shields.io/npm/v/llmify.svg?style=flat-square)](https://www.npmjs.com/package/llmify)
[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg?style=flat-square)](https://github.com/jakezegil/llmify/blob/main/LICENSE)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square)](https://github.com/jakezegil/llmify/pulls)

LLMify is made for LLMs by LLMs - a suite of powerful tools that transform your codebase into the perfect context for AI agents. Get started with a single command: `npx llmify`

## ‚ú® Features

- üìä **Visual Project Structure** - Creates a tree view of your codebase
- üìÑ **Smart Content Extraction** - Pulls content from all relevant files
- üß† **Context Optimization** - Formats output specifically for LLMs
- üîç **Intelligent Filtering** - Respects `.gitignore` and auto-creates `.llmignore`
- üõ†Ô∏è **Highly Customizable** - Control depth, paths, and patterns
- üí¨ **AI-Powered Commit Messages** - Generate detailed commit messages using LLMs
- üìù **Documentation Updates** - Automatically update docs based on code changes

## üî• Why LLMify?

Getting the right context to an LLM is critical for quality results. LLMify solves this by:

- **Saving Time** - No more manual file copying or writing commit messages
- **Improving Responses** - Gives LLMs better structural understanding of your codebase
- **Reducing Token Usage** - Smart filtering excludes irrelevant files
- **Working Everywhere** - Supports all major platforms
- **Better Commits** - Generate clear, conventional commit messages
- **Up-to-Date Docs** - Keep documentation in sync with code changes

## üì¶ Installation

### NPM (Recommended)

```bash
npm install -g llmify
```

### Direct Download

Grab the [latest release](https://github.com/jakezegil/llmify/releases) for your platform.

## üöÄ Quick Start

Generate context for your current directory:

```bash
# Creates llm.txt in current directory
llmify

# Paste into your favorite LLM
cat llm.txt | pbcopy  # macOS
cat llm.txt | xclip   # Linux
type llm.txt | clip   # Windows
```

Generate a commit message for staged changes:

```bash
# Stage your changes
git add .

# Generate and edit commit message
llmify commit

# Force commit without confirmation
llmify commit -f

# Update docs and commit
llmify commit --docs
```

## üë©‚Äçüíª Usage Examples

### Context Generation

```bash
# Specify a different project
llmify /path/to/project

# Only include a specific subdirectory
llmify -p src/components

# Custom output file 
llmify -o context_for_llm.txt

# Limit directory depth for large projects
llmify -d 3 

# Exclude specific files
llmify -e "*.test.js" -e "**/__mocks__/*"

# Include files that would otherwise be excluded
llmify -i "important-config.json"

# See what's happening (helpful for debugging)
llmify -v
```

### Commit Message Generation

```bash
# Generate commit message with default settings
llmify commit

# Skip confirmation prompt
llmify commit -f

# Update docs and commit
llmify commit --docs

# Verbose output
llmify commit -v

# Set LLM timeout (in seconds)
llmify commit --llm-timeout 60
```

## ‚öôÔ∏è Configuration

LLMify can be configured via a `.llmifyrc.yaml` file in your project root or `~/.config/llmify/config.yaml`:

```yaml
# LLM Configuration
llm:
  # The LLM provider to use (e.g., "openai", "anthropic", "ollama")
  provider: "openai"
  
  # The default model to use for general tasks
  model: "gpt-4"
  
  # Provider-specific settings
  ollama_base_url: "http://localhost:11434"  # Only used for Ollama provider

# Commit-specific settings
commit:
  # Optional: Override the default model for commit message generation
  model: "gpt-4"

# Documentation update settings
docs:
  # Optional: Override the default model for documentation updates
  model: "gpt-4"
```

Environment variables can also be used:
- `LLMIFY_LLM_PROVIDER` - Set the LLM provider
- `LLMIFY_LLM_MODEL` - Set the default model
- `OPENAI_API_KEY` - OpenAI API key
- `ANTHROPIC_API_KEY` - Anthropic API key

## üîß `.llmignore` - Control What's Included

LLMify automatically creates a `.llmignore` file with sensible defaults. Customize it to exclude any files irrelevant to your LLM conversations:

```
# Example .llmignore
*.min.js
*.csv
node_modules/
dist/
coverage/
```

## üéØ Example Output

The generated file has a clean, LLM-friendly structure:

<details>
<summary>Click to see example output</summary>

```
============================================================
Project Root: /path/to/your/project
Generated At: 2023-06-15T10:30:45Z
============================================================

## File Tree Structure

```
yourproject/
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ utils.go
‚îî‚îÄ‚îÄ docs/
    ‚îú‚îÄ‚îÄ README.md
    ‚îî‚îÄ‚îÄ usage.md
```

============================================================

## File Contents

### File: .gitignore

```
node_modules/
*.log
dist/
```

---

### File: main.go

```go
package main

import (
    "fmt"
)

func main() {
    fmt.Println("Hello, world!")
}
```
```
</details>

## üí° Pro Tips

- Include a `.llmignore` in your project templates
- Use with `--path` to focus on specific parts of your codebase
- Combine with project-specific prompts for best results
- For very large codebases, use `-d` to limit directory depth
- Use `llmify commit --docs` to keep documentation in sync
- Configure different models for different tasks in `.llmifyrc.yaml`

## ü§ù Contributing

Contributions are welcome! Feel free to:
- Report bugs
- Suggest features
- Submit pull requests

## üìù License

[MIT](https://github.com/jakezegil/llmify/blob/main/LICENSE) ¬© Jake Zegil

---

<p align="center">
  Made with ‚ù§Ô∏è for better LLM interactions
  <br>
  <a href="https://github.com/jakezegil/llmify">Star on GitHub</a> ‚Ä¢
  <a href="https://www.npmjs.com/package/llmify">View on npm</a>
</p>

```

---

### File: build-binaries.sh

```sh
#!/bin/bash

# Exit on error
set -e

# In our new structure, npm files are in a subdirectory
NPM_DIR="$(cd npm && pwd)"
OUTPUT_DIR="$NPM_DIR/bin"
GO_PROJECT_ROOT="." # Current directory

# Ensure the output directory exists
mkdir -p "$OUTPUT_DIR"

# Define targets (OS/Architecture pairs)
TARGETS=(
    "darwin/amd64"
    "darwin/arm64"
    "linux/amd64"
    "linux/arm64"
    "windows/amd64"
)

# Package name (used in Go build)
PACKAGE="github.com/jake/llmify" # Adjust to match your go.mod module path

# Version - can be set dynamically from git tags or other sources
VERSION="0.1.0"

echo "Building llmify binaries for version $VERSION..."

for TARGET in "${TARGETS[@]}"; do
    # Split GOOS and GOARCH
    IFS='/' read -r GOOS GOARCH <<< "$TARGET"

    # Set binary name
    BINARY_NAME="llmify-${GOOS}-${GOARCH}"
    if [ "$GOOS" = "windows" ]; then
        BINARY_NAME="${BINARY_NAME}.exe"
    fi

    OUTPUT_PATH="$OUTPUT_DIR/$BINARY_NAME"

    echo "Building for $GOOS/$GOARCH -> $OUTPUT_PATH"

    # Build the Go binary
    # -ldflags="-s -w" strips debug symbols and DWARF info, reducing binary size
    GOOS=$GOOS GOARCH=$GOARCH go build -trimpath -ldflags="-s -w" -o "$OUTPUT_PATH" "$GO_PROJECT_ROOT"

    # Make sure binaries are executable (especially for Linux/macOS)
    if [ "$GOOS" != "windows" ]; then
        chmod +x "$OUTPUT_PATH"
    fi
done

echo "Build complete. Binaries are in $OUTPUT_DIR" 
```

---

### File: cmd/commit.go

```go
package cmd

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/jake/llmify/internal/config"
	"github.com/jake/llmify/internal/git"
	"github.com/jake/llmify/internal/llm"
	"github.com/jake/llmify/internal/ui"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	commitUpdateDocs bool
	commitForce      bool
)

var CommitCmd = &cobra.Command{
	Use:   "commit",
	Short: "Generate a commit message for staged changes using an LLM.",
	Long: `Analyzes staged code changes (git diff --staged), generates a detailed
commit message suggestion using the configured LLM, allows editing,
and optionally updates documentation files before committing.`,
	RunE: runCommit,
}

func init() {
	CommitCmd.Flags().BoolVar(&commitUpdateDocs, "docs", false, "Attempt to automatically update relevant documentation files (*.md) based on changes.")
	CommitCmd.Flags().BoolVarP(&commitForce, "force", "f", false, "Skip the final confirmation prompt before committing.")
	// Add other flags if necessary
}

func runCommit(cmd *cobra.Command, args []string) error {
	verbose := viper.GetBool("verbose") // Get verbose flag state if set globally
	if verbose {
		log.Println("Running commit command...")
	}

	// --- 0. Load Config ---
	// Config is loaded via root command's PersistentPreRun or called explicitly here
	// Assuming GlobalConfig is populated from config.LoadConfig() called elsewhere
	if err := config.LoadConfig(); err != nil { // Call here if not done globally
		return fmt.Errorf("failed to load configuration: %w", err)
	}
	cfg := &config.GlobalConfig // Use the globally loaded config

	// --- 1. Get Staged Changes ---
	if verbose {
		log.Println("Getting staged diff...")
	}
	diff, err := git.GetStagedDiff()
	if err != nil {
		if strings.Contains(err.Error(), "no changes staged") {
			fmt.Println("No changes staged for commit.")
			return nil // Not an error for the command
		}
		return fmt.Errorf("failed to get staged changes: %w", err)
	}

	if verbose {
		log.Println("Getting staged files...")
	}
	stagedFiles, err := git.GetStagedFiles()
	if err != nil {
		return fmt.Errorf("failed to get staged file list: %w", err)
	}
	if len(stagedFiles) == 0 {
		fmt.Println("No files staged for commit (diff reported changes, but file list is empty - check git status).")
		return nil
	}

	// --- 2. Gather Context ---
	if verbose {
		log.Println("Gathering context from staged files...")
	}
	var contextBuilder strings.Builder
	repoRoot, err := git.GetRepoRoot() // Get root to construct full paths
	if err != nil {
		log.Printf("Warning: could not get repo root, using relative paths: %v", err)
		repoRoot = "." // Fallback
	}

	// TODO: Add token limiting logic here if context gets too large
	const maxContextChars = 100000 // Example limit, adjust as needed
	currentChars := 0

	for _, fileRelPath := range stagedFiles {
		fullPath := filepath.Join(repoRoot, fileRelPath)
		// Check if file exists before reading (it might be a deleted file in the diff)
		if _, statErr := os.Stat(fullPath); os.IsNotExist(statErr) {
			contextBuilder.WriteString(fmt.Sprintf("\n--- File (Deleted): %s ---\n", fileRelPath))
			continue
		}

		content, readErr := os.ReadFile(fullPath)
		if readErr != nil {
			log.Printf("Warning: could not read file %s: %v", fileRelPath, readErr)
			content = []byte(fmt.Sprintf("Error reading file: %v", readErr))
		}

		fileHeader := fmt.Sprintf("\n--- File: %s ---\n", fileRelPath)
		if currentChars+len(fileHeader)+len(content) > maxContextChars {
			remainingSpace := maxContextChars - currentChars - len(fileHeader) - 20 // reserve space for truncation message
			if remainingSpace > 0 {
				contextBuilder.WriteString(fileHeader)
				contextBuilder.Write(content[:remainingSpace])
				contextBuilder.WriteString("\n... (file truncated)\n")
			}
			log.Printf("Warning: Context truncated due to size limits. Files included: %d of %d", len(contextBuilder.String()), len(stagedFiles)) // Crude count
			break                                                                                                                                 // Stop adding more files
		}

		contextBuilder.WriteString(fileHeader)
		contextBuilder.Write(content)
		currentChars += len(fileHeader) + len(content)
	}
	fullContext := contextBuilder.String()

	// --- 3. Create LLM Client ---
	if verbose {
		log.Printf("Initializing LLM client (Provider: %s)", cfg.LLM.Provider)
	}
	llmClient, err := llm.NewLLMClient(cfg)
	if err != nil {
		return fmt.Errorf("failed to create LLM client: %w", err)
	}

	// --- 4. Generate Commit Message ---
	commitModel := cfg.Commit.Model // Use specific commit model
	if verbose {
		log.Printf("Generating commit message using model: %s...", commitModel)
	}
	commitPrompt := llm.CreateCommitPrompt(diff, fullContext)
	// Use context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(viper.GetInt("llm.timeout_seconds"))*time.Second) // Add timeout config
	defer cancel()

	proposedMessage, err := llmClient.Generate(ctx, commitPrompt, commitModel)
	if err != nil {
		return fmt.Errorf("failed to generate commit message: %w", err)
	}
	proposedMessage = strings.TrimSpace(proposedMessage) // Clean up LLM output

	// --- 5. Handle --docs flag ---
	updatedDocs := []string{}
	if commitUpdateDocs {
		if verbose {
			log.Println("Processing --docs flag...")
		}
		docsModel := cfg.Docs.Model // Use specific docs model

		// Find candidate *.md files (simple approach: walk current dir)
		// TODO: Make this smarter (use repo root, respect ignores)
		var candidateDocs []string
		err = filepath.WalkDir(".", func(path string, d os.DirEntry, err error) error {
			if err != nil {
				return err
			}
			// Basic filter: .md extension, not in .git, maybe respect .llmignore later
			if !d.IsDir() && strings.HasSuffix(strings.ToLower(d.Name()), ".md") && !strings.Contains(path, ".git"+string(filepath.Separator)) {
				// Convert to relative path if needed, or use as is if WalkDir started from '.'
				candidateDocs = append(candidateDocs, path)
			}
			return nil
		})
		if err != nil {
			log.Printf("Warning: Error scanning for documentation files: %v", err)
		}

		if verbose {
			log.Printf("Found %d potential markdown files to check.", len(candidateDocs))
		}

		for _, docPath := range candidateDocs {
			if verbose {
				log.Printf("Checking doc: %s", docPath)
			}
			docContent, readErr := os.ReadFile(docPath)
			if readErr != nil {
				log.Printf("Warning: could not read doc file %s: %v", docPath, readErr)
				continue
			}

			docPrompt := llm.CreateDocsUpdatePrompt(diff, string(docContent))
			ctxDocs, cancelDocs := context.WithTimeout(context.Background(), time.Duration(viper.GetInt("llm.timeout_seconds"))*time.Second) // Separate timeout

			docResponse, llmErr := llmClient.Generate(ctxDocs, docPrompt, docsModel)
			cancelDocs() // Release context resources
			if llmErr != nil {
				log.Printf("Warning: LLM failed to process doc %s: %v", docPath, llmErr)
				continue
			}

			needsUpdate, newContent := llm.NeedsDocUpdate(docResponse)
			if needsUpdate {
				if verbose {
					log.Printf("LLM proposed update for: %s", docPath)
				}
				// Write the new content back to the file
				writeErr := os.WriteFile(docPath, []byte(newContent), 0644)
				if writeErr != nil {
					log.Printf("Warning: Failed to write updated doc %s: %v", docPath, writeErr)
				} else {
					updatedDocs = append(updatedDocs, docPath) // Add to list for staging
				}
			} else {
				if verbose {
					log.Printf("No update needed for: %s", docPath)
				}
			}
		}

		// Stage updated docs
		if len(updatedDocs) > 0 {
			if verbose {
				log.Printf("Staging updated documentation files: %v", updatedDocs)
			}
			err = git.AddFiles(updatedDocs)
			if err != nil {
				// Log warning but maybe proceed with commit? Or make it fatal?
				log.Printf("Warning: Failed to stage updated docs: %v", err)
			} else {
				fmt.Printf("Updated and staged documentation files: %s\n", strings.Join(updatedDocs, ", "))
			}
		}
	}

	// --- 6. Edit, Confirm, Commit Loop ---
	finalMessage := proposedMessage
	for {
		fmt.Println("\n--- Proposed Commit Message ---")
		fmt.Println(finalMessage)
		fmt.Println("-----------------------------")

		// Allow editing
		editedMessage, editErr := ui.EditCommitMessage(finalMessage)
		if editErr != nil {
			return fmt.Errorf("failed during commit message editing: %w", editErr)
		}
		finalMessage = strings.TrimSpace(editedMessage)
		if finalMessage == "" {
			fmt.Println("Commit aborted: Empty commit message.")
			return nil
		}

		// Confirm
		proceed, editAgain, confirmErr := ui.ConfirmCommit(commitForce)
		if confirmErr != nil {
			return confirmErr // Error reading confirmation
		}

		if proceed {
			break // Exit loop to commit
		}
		if !editAgain {
			fmt.Println("Commit aborted.")
			return nil // User chose 'no'
		}
		// Otherwise, loop back to edit again
	}

	// --- 7. Execute Commit ---
	if verbose {
		log.Println("Executing git commit...")
	}
	err = git.Commit(finalMessage)
	if err != nil {
		return fmt.Errorf("git commit execution failed: %w", err)
	}

	fmt.Println("Commit successful.")
	return nil
}

```

---

### File: crawler.go

```go
package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	gitignore "github.com/sabhiram/go-gitignore"
)

// CrawlResult holds the results of the crawl operation.
type CrawlResult struct {
	IncludedFiles []string // List of relative paths to include
	FileTree      string   // Generated file tree string
	ExcludedCount int      // Count of files/dirs excluded
	IncludedCount int      // Count of files/dirs included (in tree)
}

// CreateDefaultLLMIgnoreFile creates a .llmignore file with common defaults
func CreateDefaultLLMIgnoreFile(rootDir string) error {
	llmignorePath := filepath.Join(rootDir, ".llmignore")

	// Common files/patterns to exclude from LLM context
	defaults := []string{
		"# Default .llmignore created by llmify",
		"# Add or remove patterns as needed",
		"",
		"# Package lock files (large, machine-generated)",
		"package-lock.json",
		"yarn.lock",
		"pnpm-lock.yaml",
		"composer.lock",
		"Cargo.lock",
		"Gemfile.lock",
		"go.sum",
		"",
		"# Build output and artifacts",
		"dist/",
		"build/",
		"coverage/",
		"*.min.js",
		"*.min.css",
		"",
		"# Large data files",
		"*.csv",
		"*.xlsx",
		"*.parquet",
		"*.sql",
		"*.db",
		"*.sqlite",
		"",
		"# Images and media (binary content)",
		"*.jpg",
		"*.jpeg",
		"*.png",
		"*.gif",
		"*.ico",
		"*.svg",
		"*.webp",
		"",
		"# Generated or compiled content",
		"**/*.map",
		"**/__pycache__/",
		"**/.pytest_cache/",
		"**/.next/",
		"**/.nuxt/",
		"",
		"# Machine-specific configuration",
		".DS_Store",
		"Thumbs.db",
		".env.local",
		".idea/",
		".vscode/",
		"*.swp",
		"*.swo",
	}

	// Join lines with newlines and write to file
	content := strings.Join(defaults, "\n") + "\n"

	// Write to file
	if err := WriteStringToFile(llmignorePath, content); err != nil {
		return fmt.Errorf("creating default .llmignore file: %w", err)
	}

	return nil
}

// LoadIgnoreMatcher loads ignore rules from .gitignore and .llmignore.
func LoadIgnoreMatcher(rootDir string, useGitignore bool, useLLMIgnore bool) (*gitignore.GitIgnore, error) {
	var patterns []string
	gitignorePath := filepath.Join(rootDir, ".gitignore")
	llmignorePath := filepath.Join(rootDir, ".llmignore")

	readFileLines := func(path string) ([]string, error) {
		content, err := os.ReadFile(path)
		if err != nil {
			if os.IsNotExist(err) {
				return []string{}, nil // File not existing is not an error here
			}
			return nil, fmt.Errorf("reading ignore file %s: %w", path, err)
		}
		return strings.Split(string(content), "\n"), nil
	}

	if useGitignore {
		gitLines, err := readFileLines(gitignorePath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: %v\n", err) // Log error but continue
		} else {
			patterns = append(patterns, gitLines...)
		}
	}

	if useLLMIgnore {
		// Check if .llmignore exists, create it with defaults if not
		if _, err := os.Stat(llmignorePath); os.IsNotExist(err) {
			fmt.Fprintf(os.Stderr, "No .llmignore found. Creating one with default patterns...\n")
			if err := CreateDefaultLLMIgnoreFile(rootDir); err != nil {
				fmt.Fprintf(os.Stderr, "Warning: Failed to create default .llmignore: %v\n", err)
				// Continue without .llmignore
			} else {
				fmt.Fprintf(os.Stderr, "Created default .llmignore file at %s\n", llmignorePath)
			}
		}

		llmLines, err := readFileLines(llmignorePath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: %v\n", err) // Log error but continue
		} else {
			patterns = append(patterns, llmLines...)
		}
	}

	// Add common defaults that should always be ignored
	patterns = append(patterns,
		".git/",         // Crucial
		"__pycache__/",  // Python cache
		"node_modules/", // Node.js dependencies
		"vendor/",       // Go dependencies (often)
		"build/",        // Common build output
		"dist/",         // Common distribution output
		"target/",       // Common build output (Java/Rust)
		"*.pyc",         // Python bytecode
		"*.pyo",
		"*.class",   // Java bytecode
		"*.log",     // Log files
		"*.swp",     // Vim swap files
		".DS_Store", // macOS metadata
		"Thumbs.db", // Windows metadata
		// Add more common temporary/build/cache files if needed
	)

	// Ensure rootDir is absolute for reliable matching
	_, err := filepath.Abs(rootDir)
	if err != nil {
		return nil, fmt.Errorf("getting absolute path for root %s: %w", rootDir, err)
	}

	// go-gitignore expects patterns relative to the root where .gitignore would be
	ignorer := gitignore.CompileIgnoreLines(patterns...)
	// Note: The go-gitignore library doesn't have AddPatterns method
	// We're already compiling with patterns relative to the root

	return ignorer, nil
}

// CrawlProject walks the directory, applies filters, and gathers content.
func CrawlProject(
	rootDir string,
	outputFilename string,
	targetPathRel string, // New: Relative path to filter by
	ignorer *gitignore.GitIgnore,
	cmdExcludes []string, // Patterns from command line --exclude
	cmdIncludes []string, // Patterns from command line --include
	maxDepth int,
	excludeBinary bool,
	verbose bool,
) (*CrawlResult, error) {
	absRootDir, err := filepath.Abs(rootDir)
	if err != nil {
		return nil, fmt.Errorf("getting absolute path for %s: %w", rootDir, err)
	}
	absOutputFilename := filepath.Join(absRootDir, outputFilename) // Get absolute path for output file

	// Determine absolute target path if provided
	var absTargetPath string
	var isTargetPathDir bool
	if targetPathRel != "" {
		absTargetPath = filepath.Join(absRootDir, targetPathRel)
		targetInfo, err := os.Stat(absTargetPath)
		// We assume stat worked because main.go checked it
		if err != nil {
			// This should ideally not happen due to checks in main.go, but handle defensively
			return nil, fmt.Errorf("cannot stat target path %s during crawl: %w", absTargetPath, err)
		}
		isTargetPathDir = targetInfo.IsDir()
	}

	// Compile command-line patterns (using gitignore syntax for simplicity)
	excludeMatcher := gitignore.CompileIgnoreLines(cmdExcludes...)
	includeMatcher := gitignore.CompileIgnoreLines(cmdIncludes...) // Note: includes need careful handling

	includedFiles := []string{}
	includedPathsForTree := make(map[string]os.DirEntry) // For building the tree
	excludedCount := 0
	includedCount := 0

	walkErr := filepath.WalkDir(absRootDir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			// Error accessing a file/directory, report and potentially skip
			fmt.Fprintf(os.Stderr, "Warning: Error accessing %s: %v\n", path, err)
			if d != nil && d.IsDir() {
				return filepath.SkipDir // Skip contents of this directory
			}
			return nil // Skip this file/entry
		}

		// Use absolute path for most checks
		absPath := path // WalkDir provides absolute paths if root is absolute

		// --- Filtering Logic ---

		// 0. Get relative path for matching against *patterns* and for final output list
		relPath, err := filepath.Rel(absRootDir, absPath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Could not get relative path for %s: %v\n", absPath, err)
			return nil // Skip if relative path fails
		}
		if relPath == "." { // Skip the root directory itself from inclusion checks, but don't skip walk
			return nil
		}

		// A. Check --path filter FIRST if provided
		if absTargetPath != "" {
			isInsideTargetPath := false
			if absPath == absTargetPath {
				isInsideTargetPath = true // Exact match (could be file or dir)
			} else if isTargetPathDir && strings.HasPrefix(absPath, absTargetPath+string(filepath.Separator)) {
				isInsideTargetPath = true // Path is inside the target directory
			}

			if !isInsideTargetPath {
				if verbose {
					fmt.Printf("Exclude (outside --path %s): %s\n", targetPathRel, relPath)
				}
				excludedCount++
				// Optimization: If it's a directory not matching the target prefix, skip it entirely
				if d.IsDir() && !strings.HasPrefix(absTargetPath, absPath+string(filepath.Separator)) {
					return filepath.SkipDir
				}
				return nil // Skip this file/entry
			}
		}

		// Ensure paths use forward slashes for consistent matching with gitignore patterns
		matchPath := filepath.ToSlash(relPath)
		if d.IsDir() {
			matchPath += "/" // Append slash for directories as gitignore patterns often expect
		}

		// 1. Check depth limit (relative path parts + 1 for root)
		if maxDepth > 0 {
			depth := len(strings.Split(filepath.ToSlash(relPath), "/"))
			// Adjust depth logic slightly: root is depth 0, its children are depth 1
			if depth > maxDepth {
				if verbose {
					fmt.Printf("Exclude (depth > %d): %s\n", maxDepth, relPath)
				}
				excludedCount++
				if d.IsDir() {
					return filepath.SkipDir
				}
				return nil
			}
		}

		// 2. Never include the output file itself
		if absPath == absOutputFilename {
			if verbose {
				fmt.Printf("Exclude (output file): %s\n", relPath)
			}
			excludedCount++
			if d.IsDir() {
				return filepath.SkipDir
			} // Should not happen for the output file, but check anyway
			return nil
		}

		// 3. Check .gitignore / .llmignore patterns
		if ignorer != nil && ignorer.MatchesPath(path) {
			// Is there an explicit command-line include that overrides this?
			isIncluded := includeMatcher != nil && includeMatcher.MatchesPath(path) // Check if explicitly included
			if !isIncluded {
				if verbose {
					fmt.Printf("Exclude (ignore file): %s\n", relPath)
				}
				excludedCount++
				if d.IsDir() {
					return filepath.SkipDir
				} // Skip ignored directories
				return nil
			}
			if verbose {
				fmt.Printf("Override ignore (cmd include): %s\n", relPath)
			}
		}

		// 4. Check command-line exclude patterns
		if excludeMatcher != nil && excludeMatcher.MatchesPath(path) {
			// Is there an explicit command-line include that overrides this?
			isIncluded := includeMatcher != nil && includeMatcher.MatchesPath(path) // Check if explicitly included
			if !isIncluded {
				if verbose {
					fmt.Printf("Exclude (cmd exclude): %s\n", relPath)
				}
				excludedCount++
				if d.IsDir() {
					return filepath.SkipDir
				}
				return nil
			}
			if verbose {
				fmt.Printf("Override cmd exclude (cmd include): %s\n", relPath)
			}
		}

		// 5. If it's a file, check if it's binary (unless overridden by include)
		if !d.IsDir() {
			isIncluded := includeMatcher != nil && includeMatcher.MatchesPath(path)
			if !isIncluded && excludeBinary {
				isText, textCheckErr := IsLikelyTextFile(path)
				if textCheckErr != nil {
					fmt.Fprintf(os.Stderr, "Warning: Could not check file type for %s: %v\n", path, textCheckErr)
					// Decide whether to include or exclude on error - let's exclude by default
					isText = false
				}
				if !isText {
					if verbose {
						fmt.Printf("Exclude (binary): %s\n", relPath)
					}
					excludedCount++
					return nil // Skip binary files
				}
			}
		}

		// --- If we reach here, the path should be included ---
		if verbose {
			fmt.Printf("Include: %s\n", relPath)
		}
		includedPathsForTree[path] = d // Store entry for tree building
		includedCount++
		if !d.IsDir() {
			includedFiles = append(includedFiles, relPath) // Add relative path to list
		}

		return nil // Continue walking
	})

	if walkErr != nil {
		return nil, fmt.Errorf("error during directory walk: %w", walkErr)
	}

	// Sort included files for consistent output
	sort.Strings(includedFiles)

	// Generate the file tree using only the included paths
	includeCriteria := func(p string, d os.DirEntry) bool {
		_, exists := includedPathsForTree[p]
		return exists
	}
	treeString, err := GenerateFileTree(absRootDir, includeCriteria, maxDepth)
	if err != nil {
		return nil, fmt.Errorf("generating file tree: %w", err)
	}

	result := &CrawlResult{
		IncludedFiles: includedFiles,
		FileTree:      treeString,
		ExcludedCount: excludedCount,
		IncludedCount: includedCount, // This counts files and dirs added to the tree map
	}

	return result, nil
}

// BuildOutputContent combines tree and file contents into the final string.
func BuildOutputContent(rootDir string, result *CrawlResult, includeHeader bool) (string, error) {
	var builder strings.Builder
	absRootDir, _ := filepath.Abs(rootDir) // Assume rootDir is valid now

	// Optional Header
	if includeHeader {
		builder.WriteString("============================================================\n")
		builder.WriteString(fmt.Sprintf("Project Root: %s\n", absRootDir))
		builder.WriteString(fmt.Sprintf("Generated At: %s\n", time.Now().Format(time.RFC3339)))
		// Could add command-line args used here too
		builder.WriteString("============================================================\n\n")
	}

	// File Tree Section
	builder.WriteString("## File Tree Structure\n\n")
	builder.WriteString("```\n")
	builder.WriteString(result.FileTree)
	builder.WriteString("```\n\n")
	builder.WriteString("============================================================\n\n")

	// File Content Section
	builder.WriteString("## File Contents\n\n")

	separator := "\n\n---\n\n" // Separator between files

	for i, relPath := range result.IncludedFiles {
		fullPath := filepath.Join(absRootDir, relPath)
		content, err := ReadFileContent(fullPath)
		if err != nil {
			// Log error but try to continue with other files
			fmt.Fprintf(os.Stderr, "Warning: Failed to read content for %s: %v\n", relPath, err)
			content = fmt.Sprintf("Error reading file: %v", err) // Include error message in output
		}

		// Add file path header
		builder.WriteString(fmt.Sprintf("### File: %s\n\n", filepath.ToSlash(relPath))) // Use forward slashes
		builder.WriteString("```")
		// Try to detect language from extension for syntax highlighting hint
		ext := strings.TrimPrefix(filepath.Ext(relPath), ".")
		if ext != "" {
			builder.WriteString(ext) // e.g., ```go, ```python
		}
		builder.WriteString("\n")
		builder.WriteString(content)
		builder.WriteString("\n```") // End code block

		if i < len(result.IncludedFiles)-1 {
			builder.WriteString(separator)
		}
	}

	return builder.String(), nil
}

```

---

### File: go.mod

```mod
module github.com/jake/llmify

go 1.21.6

require (
	github.com/fsnotify/fsnotify v1.8.0 // indirect
	github.com/go-viper/mapstructure/v2 v2.2.1 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/pelletier/go-toml/v2 v2.2.3 // indirect
	github.com/sabhiram/go-gitignore v0.0.0-20210923224102-525f6e181f06 // indirect
	github.com/sagikazarmark/locafero v0.7.0 // indirect
	github.com/sashabaranov/go-openai v1.38.1 // indirect
	github.com/sourcegraph/conc v0.3.0 // indirect
	github.com/spf13/afero v1.12.0 // indirect
	github.com/spf13/cast v1.7.1 // indirect
	github.com/spf13/cobra v1.9.1 // indirect
	github.com/spf13/pflag v1.0.6 // indirect
	github.com/spf13/viper v1.20.1 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	go.uber.org/atomic v1.9.0 // indirect
	go.uber.org/multierr v1.9.0 // indirect
	golang.org/x/sys v0.29.0 // indirect
	golang.org/x/text v0.21.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

```

---

### File: internal/config/config.go

```go
package config

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/viper"
)

type LLMConfig struct {
	Provider string `mapstructure:"provider"`
	Model    string `mapstructure:"model"`
	// Add provider-specific fields if needed, e.g.:
	OllamaBaseURL string `mapstructure:"ollama_base_url"`
	// API keys are typically handled via environment variables
}

type CommitConfig struct {
	Model string `mapstructure:"model"` // Optional override
}

type DocsConfig struct {
	Model string `mapstructure:"model"` // Optional override
	// Could add patterns for doc files here:
	// Patterns []string `mapstructure:"patterns"`
}

type Config struct {
	LLM    LLMConfig    `mapstructure:"llm"`
	Commit CommitConfig `mapstructure:"commit"`
	Docs   DocsConfig   `mapstructure:"docs"`
}

var GlobalConfig Config

func LoadConfig() error {
	v := viper.New()

	// 1. Set Defaults
	v.SetDefault("llm.provider", "openai")
	v.SetDefault("llm.model", "gpt-4") // Adjust default model as needed
	v.SetDefault("llm.ollama_base_url", "http://localhost:11434")
	// Defaults for Commit and Docs models will inherit from llm.model if not set

	// 2. Set config file paths
	home, _ := os.UserHomeDir()
	configName := "config"
	configType := "yaml"
	configPaths := []string{
		".", // Project root .llmifyrc.yaml (or .llmifyrc)
	}
	if home != "" {
		configPaths = append(configPaths, filepath.Join(home, ".config", "llmify")) // ~/.config/llmify/config.yaml
	}

	v.SetConfigName(configName) // Name of config file (without extension)
	v.SetConfigType(configType)
	for _, p := range configPaths {
		v.AddConfigPath(p)
	}
	v.SetConfigName(".llmifyrc") // Also support .llmifyrc.yaml in project root
	v.AddConfigPath(".")

	// 3. Read config file (optional)
	err := v.ReadInConfig()
	if err != nil {
		if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
			// Config file was found but another error was produced
			return fmt.Errorf("error reading config file: %w", err)
		}
		// Config file not found; ignore error if it's just not found
		fmt.Fprintln(os.Stderr, "Info: No config file found, using defaults and environment variables.")
	}

	// 4. Set environment variable binding
	v.SetEnvPrefix("LLMIFY") // e.g., LLMIFY_LLM_PROVIDER
	v.AutomaticEnv()
	// Allow specific API keys to be picked up directly
	v.BindEnv("llm.api_key.openai", "OPENAI_API_KEY")
	v.BindEnv("llm.api_key.anthropic", "ANTHROPIC_API_KEY")
	// Add others as needed

	// 5. Unmarshal into GlobalConfig
	err = v.Unmarshal(&GlobalConfig)
	if err != nil {
		return fmt.Errorf("unable to decode config: %w", err)
	}

	// Apply overrides if specific models aren't set
	if GlobalConfig.Commit.Model == "" {
		GlobalConfig.Commit.Model = GlobalConfig.LLM.Model
	}
	if GlobalConfig.Docs.Model == "" {
		GlobalConfig.Docs.Model = GlobalConfig.LLM.Model
	}

	// For API Keys, prefer specific env vars if not set via LLMIFY_LLM_API_KEY_PROVIDER
	// This logic might be better placed within the client factory, but shown here for clarity
	if viper.GetString("llm.api_key.openai") != "" {
		// Store it somewhere accessible if needed, but often the SDK reads it directly
	}

	if viper.GetBool("verbose") { // Assuming verbose flag sets this globally via viper
		fmt.Fprintf(os.Stderr, "Loaded Config: %+v\n", GlobalConfig)
	}

	return nil
}

// Helper to get API key for the current provider
func GetAPIKey(provider string) string {
	// Viper reads bound env vars automatically
	key := viper.GetString(fmt.Sprintf("llm.api_key.%s", strings.ToLower(provider)))
	if key == "" {
		// Fallback to standard env vars if Viper binding didn't pick it up
		switch strings.ToLower(provider) {
		case "openai":
			key = os.Getenv("OPENAI_API_KEY")
		case "anthropic":
			key = os.Getenv("ANTHROPIC_API_KEY")
			// Add other cases
		}
	}
	return key
}

```

---

### File: internal/git/git.go

```go
package git

import (
	"bytes"
	"fmt"
	"os/exec"
	"strings"
)

// runGitCommand executes a git command and returns its stdout output.
func runGitCommand(args ...string) (string, error) {
	cmd := exec.Command("git", args...)
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr
	// Ensure git commands run relative to the repo root if possible
	// This might need refinement depending on where llmify is executed from.
	// For now, assume execution within the repo.

	err := cmd.Run()
	if err != nil {
		return "", fmt.Errorf("git command failed: 'git %s': %v\nStderr: %s", strings.Join(args, " "), err, stderr.String())
	}
	return strings.TrimSpace(stdout.String()), nil
}

// GetStagedDiff returns the output of `git diff --staged`.
func GetStagedDiff() (string, error) {
	diff, err := runGitCommand("diff", "--staged")
	if err != nil {
		// Distinguish between error and no diff?
		// For now, treat any error as potentially problematic
		return "", fmt.Errorf("failed to get staged diff: %w", err)
	}
	if diff == "" {
		return "", fmt.Errorf("no changes staged for commit") // Specific error for no changes
	}
	return diff, nil
}

// GetStagedFiles returns a list of relative paths of staged files.
func GetStagedFiles() ([]string, error) {
	output, err := runGitCommand("diff", "--staged", "--name-only", "--relative")
	if err != nil {
		return nil, fmt.Errorf("failed to get staged files: %w", err)
	}
	if output == "" {
		return []string{}, nil // No files staged
	}
	files := strings.Split(output, "\n")
	// Filter out empty strings if any
	result := []string{}
	for _, f := range files {
		if f != "" {
			result = append(result, f)
		}
	}
	return result, nil
}

// Commit performs git commit with the given message.
func Commit(message string) error {
	_, err := runGitCommand("commit", "-m", message)
	if err != nil {
		return fmt.Errorf("git commit failed: %w", err)
	}
	return nil
}

// AddFiles stages the specified files.
func AddFiles(files []string) error {
	if len(files) == 0 {
		return nil
	}
	args := append([]string{"add", "--"}, files...)
	_, err := runGitCommand(args...)
	if err != nil {
		return fmt.Errorf("git add failed for files %v: %w", files, err)
	}
	return nil
}

// GetRepoRoot finds the root directory of the git repository.
func GetRepoRoot() (string, error) {
	root, err := runGitCommand("rev-parse", "--show-toplevel")
	if err != nil {
		return "", fmt.Errorf("failed to find git repository root: %w", err)
	}
	return root, nil
}

```

---

### File: internal/llm/client.go

```go
package llm

import (
	"context"
	"fmt"

	"github.com/jake/llmify/internal/config" // Use the correct module path
)

// LLMClient defines the interface for interacting with different LLM providers.
type LLMClient interface {
	Generate(ctx context.Context, prompt string, model string) (string, error)
}

// NewLLMClient creates a new LLM client based on the configuration.
func NewLLMClient(cfg *config.Config) (LLMClient, error) {
	apiKey := config.GetAPIKey(cfg.LLM.Provider)

	switch cfg.LLM.Provider {
	case "openai":
		if apiKey == "" {
			return nil, fmt.Errorf("OpenAI API key not found (set OPENAI_API_KEY or LLMIFY_LLM_API_KEY_OPENAI)")
		}
		return NewOpenAIClient(apiKey), nil
	// case "anthropic":
	//     // ... implementation ...
	// case "ollama":
	// 	   return NewOllamaClient(cfg.LLM.OllamaBaseURL)
	default:
		return nil, fmt.Errorf("unsupported LLM provider: %s", cfg.LLM.Provider)
	}
}

```

---

### File: internal/llm/openai.go

```go
package llm

import (
	"context"
	"fmt"

	openai "github.com/sashabaranov/go-openai"
)

type OpenAIClient struct {
	client *openai.Client
}

func NewOpenAIClient(apiKey string) *OpenAIClient {
	return &OpenAIClient{
		client: openai.NewClient(apiKey),
	}
}

func (c *OpenAIClient) Generate(ctx context.Context, prompt string, model string) (string, error) {
	resp, err := c.client.CreateChatCompletion(
		ctx,
		openai.ChatCompletionRequest{
			Model: model,
			Messages: []openai.ChatCompletionMessage{
				{
					Role:    openai.ChatMessageRoleSystem,
					Content: "You are a helpful assistant.", // Or more specific system prompt
				},
				{
					Role:    openai.ChatMessageRoleUser,
					Content: prompt,
				},
			},
			// Add Temperature, MaxTokens etc. from config if desired
		},
	)

	if err != nil {
		return "", fmt.Errorf("openai chat completion error: %w", err)
	}

	if len(resp.Choices) == 0 {
		return "", fmt.Errorf("openai returned no choices")
	}

	return resp.Choices[0].Message.Content, nil
}

```

---

### File: internal/llm/prompts.go

```go
package llm

import (
	"fmt"
	"strings"
)

const commitPromptTemplate = `
You are an expert programmer and Git user, tasked with writing a detailed and clear commit message.
Analyze the following code changes (provided as a git diff) and the context of the changed files.

Follow the Conventional Commits specification (https://www.conventionalcommits.org/).
The commit message should have:
1. A type prefix (e.g., feat, fix, refactor, chore, docs, style, test, perf).
2. A concise subject line summarizing the change (imperative mood, lowercase).
3. A blank line.
4. A detailed body explaining the 'what' and 'why' of the changes. Be specific. Mention key functions/files modified and the reasoning. If it fixes an issue, reference it.
5. Optionally, a footer for BREAKING CHANGES or issue references (e.g., Fixes #123).

Here is the git diff:
--- DIFF START ---
%s
--- DIFF END ---

Here is the context of the changed files (content might be truncated):
--- CONTEXT START ---
%s
--- CONTEXT END ---

Generate the commit message now:
`

const docsUpdatePromptTemplate = `
You are an expert technical writer tasked with updating documentation based on code changes.
Analyze the following code changes (provided as a git diff) and the existing documentation section.

Update the documentation provided below ONLY IF NECESSARY to accurately reflect the code changes.
Focus on:
- Changes to function signatures, parameters, or return types.
- Added or removed features relevant to the documentation.
- Changes in usage examples.
- Clarifications needed based on the code modifications.

If the documentation section does not need any updates based on the provided diff, respond with the exact phrase: "NO_UPDATE_NEEDED" and nothing else.

Otherwise, provide the COMPLETE, updated documentation section. Do NOT just describe the changes; output the full modified text.

Here is the git diff of the code changes:
--- DIFF START ---
%s
--- DIFF END ---

Here is the CURRENT documentation section to update:
--- DOCS START ---
%s
--- DOCS END ---

Provide the updated documentation section or "NO_UPDATE_NEEDED":
`

func CreateCommitPrompt(diff string, context string) string {
	return fmt.Sprintf(commitPromptTemplate, diff, context)
}

func CreateDocsUpdatePrompt(diff string, docContent string) string {
	return fmt.Sprintf(docsUpdatePromptTemplate, diff, docContent)
}

// Helper function to check LLM response for docs update
func NeedsDocUpdate(response string) (bool, string) {
	trimmedResponse := strings.TrimSpace(response)
	if trimmedResponse == "NO_UPDATE_NEEDED" {
		return false, ""
	}
	// Assume any other non-empty response is the updated content
	return len(trimmedResponse) > 0, trimmedResponse
}

```

---

### File: internal/ui/editor.go

```go
package ui

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"
)

// DefaultEditorOrder defines the fallback order for text editors.
var DefaultEditorOrder = []string{"vim", "nano", "vi", "emacs", "code", "notepad"} // Add more as needed

// findEditor determines the editor to use based on environment or defaults.
func findEditor() (string, error) {
	editor := os.Getenv("EDITOR")
	if editor != "" {
		// Ensure the editor command exists
		path, err := exec.LookPath(editor)
		if err == nil {
			return path, nil
		}
	}
	// Try default editors
	for _, ed := range DefaultEditorOrder {
		path, err := exec.LookPath(ed)
		if err == nil {
			return path, nil
		}
	}
	return "", fmt.Errorf("no suitable text editor found in PATH or $EDITOR")
}

// EditCommitMessage launches an editor to allow modification of the message.
func EditCommitMessage(initialMessage string) (string, error) {
	editorPath, err := findEditor()
	if err != nil {
		return "", fmt.Errorf("cannot find editor: %w", err)
	}

	tmpfile, err := ioutil.TempFile("", "llmify-commit-*.msg")
	if err != nil {
		return "", fmt.Errorf("failed to create temporary file: %w", err)
	}
	defer os.Remove(tmpfile.Name()) // Clean up

	// Write initial message to temp file
	if _, err := tmpfile.WriteString(initialMessage); err != nil {
		tmpfile.Close()
		return "", fmt.Errorf("failed to write to temporary file: %w", err)
	}
	if err := tmpfile.Close(); err != nil {
		return "", fmt.Errorf("failed to close temporary file: %w", err)
	}

	// Prepare and run the editor command
	cmd := exec.Command(editorPath, tmpfile.Name())
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	fmt.Printf("Launching editor (%s) for commit message...\n", editorPath)
	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("editor '%s' failed: %w", editorPath, err)
	}

	// Read the potentially modified content back
	contentBytes, err := ioutil.ReadFile(tmpfile.Name())
	if err != nil {
		return "", fmt.Errorf("failed to read back from temporary file: %w", err)
	}

	return string(contentBytes), nil
}

// ConfirmCommit prompts the user unless force is true. Returns true if commit should proceed.
func ConfirmCommit(force bool) (bool, bool, error) { // Returns (proceed, editAgain, error)
	if force {
		return true, false, nil
	}

	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Commit with the edited message? [Y/n/e(dit)] ")
	response, err := reader.ReadString('\n')
	if err != nil {
		return false, false, fmt.Errorf("failed to read confirmation: %w", err)
	}

	response = strings.ToLower(strings.TrimSpace(response))

	switch response {
	case "y", "yes", "": // Default to yes
		return true, false, nil
	case "e", "edit":
		return false, true, nil // Signal to edit again
	case "n", "no":
		return false, false, nil // Abort
	default:
		fmt.Println("Invalid response. Aborting commit.")
		return false, false, nil
	}
}

```

---

### File: main.go

```go
package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/jake/llmify/cmd"
	"github.com/jake/llmify/internal/config"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	outputFile    string
	excludes      []string
	includes      []string
	targetPath    string
	maxDepth      int
	noGitignore   bool
	noLLMignore   bool
	excludeBinary bool
	verboseFlag   bool
	includeHeader bool
	rootDir       string // Root directory for the crawl
	llmTimeout    int    // Timeout in seconds for LLM API calls
)

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

var rootCmd = &cobra.Command{
	Use:   "llmify [directory]",
	Short: "Tools to optimize codebases for LLMs and assist with development workflows.",
	Long: `llmify provides tools to prepare codebases for Large Language Models (LLMs)
and leverage LLMs for tasks like generating commit messages.

Default behavior (without subcommand):
Crawls a project directory, respects ignore rules, and creates a single text file
('llm.txt') containing a file tree and relevant file contents for LLM context.`,
	PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
		// Bind the verbose flag to viper BEFORE loading config
		viper.BindPFlag("verbose", cmd.PersistentFlags().Lookup("verbose"))
		viper.BindPFlag("llm.timeout_seconds", cmd.PersistentFlags().Lookup("llm-timeout")) // Bind timeout config

		// Load configuration once for all commands
		if err := config.LoadConfig(); err != nil {
			return fmt.Errorf("failed to load configuration: %w", err)
		}
		// Set verbose based on viper AFTER loading config/env vars
		verboseFlag = viper.GetBool("verbose") // Update global var if needed elsewhere
		return nil
	},
	Args: cobra.MaximumNArgs(1), // Root command still takes optional directory for default action
	RunE: runRootCmd,            // Separate function for root command's logic
}

// runRootCmd contains the original logic of the root command (context dumping)
func runRootCmd(cmd *cobra.Command, args []string) error {
	// Check if a subcommand was executed, if so, don't run root logic
	// Cobra usually handles this, but an explicit check can be added if needed.
	// if cmd.HasSubCommands() && cmd.CalledAs() == "llmify" { ... }

	// --- Start of original RunE logic ---
	if verboseFlag { // Use the flag variable bound to viper
		fmt.Fprintln(os.Stderr, "Running default context generation...")
	}

	// Determine root directory (same as before)
	if len(args) > 0 {
		rootDir = args[0]
	} else {
		var err error
		rootDir, err = os.Getwd()
		if err != nil {
			return fmt.Errorf("failed to get current working directory: %w", err)
		}
	}

	// Validate root directory (same as before)
	info, err := os.Stat(rootDir)
	if err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("root directory not found: %s", rootDir)
		}
		return fmt.Errorf("failed to access root directory %s: %w", rootDir, err)
	}
	if !info.IsDir() {
		return fmt.Errorf("specified path is not a directory: %s", rootDir)
	}

	// Normalize target path (same as before)
	var absTargetPath string
	if targetPath != "" {
		// Clean the path and make it relative to rootDir
		targetPath = filepath.Clean(targetPath)
		// Ensure it doesn't try to escape the root directory
		if strings.HasPrefix(targetPath, ".."+string(filepath.Separator)) || targetPath == ".." {
			return fmt.Errorf("target path cannot be outside the root directory: %s", targetPath)
		}
		absTargetPath = filepath.Join(rootDir, targetPath)

		// Check if the target path exists
		_, err := os.Stat(absTargetPath)
		if err != nil {
			if os.IsNotExist(err) {
				return fmt.Errorf("target path not found: %s", absTargetPath)
			}
			return fmt.Errorf("failed to access target path %s: %w", absTargetPath, err)
		}
	}

	if verboseFlag {
		fmt.Fprintf(os.Stderr, "Starting crawl in: %s\n", rootDir)
		if targetPath != "" {
			fmt.Fprintf(os.Stderr, "Filtering for specific path: %s (absolute: %s)\n", targetPath, absTargetPath)
		}
		fmt.Fprintf(os.Stderr, "Output file: %s\n", outputFile)
		fmt.Fprintf(os.Stderr, "Using .gitignore: %t\n", !noGitignore)
		fmt.Fprintf(os.Stderr, "Using .llmignore: %t\n", !noLLMignore)
		fmt.Fprintf(os.Stderr, "Excluding binary files: %t\n", excludeBinary)
		fmt.Fprintf(os.Stderr, "Max depth: %d (0 means unlimited)\n", maxDepth)
		fmt.Fprintf(os.Stderr, "Command excludes: %v\n", excludes)
		fmt.Fprintf(os.Stderr, "Command includes: %v\n", includes)
	}

	// --- Main Logic ---
	// 1. Load ignore rules
	ignorer, err := LoadIgnoreMatcher(rootDir, !noGitignore, !noLLMignore)
	if err != nil {
		return fmt.Errorf("failed to load ignore patterns: %w", err)
	}

	// 2. Crawl project
	crawlResult, err := CrawlProject(rootDir, outputFile, targetPath, ignorer, excludes, includes, maxDepth, excludeBinary, verboseFlag)
	if err != nil {
		return fmt.Errorf("failed to crawl project: %w", err)
	}

	// 3. Build the final output content
	outputContent, err := BuildOutputContent(rootDir, crawlResult, includeHeader)
	if err != nil {
		return fmt.Errorf("failed to build output content: %w", err)
	}

	// 4. Write to output file
	// Ensure the output path is relative to the CWD *unless* an absolute path was given
	outputPath := outputFile
	if !filepath.IsAbs(outputFile) {
		cwd, _ := os.Getwd() // Error getting CWD unlikely after initial checks
		outputPath = filepath.Join(cwd, outputFile)
	} else {
		// If outputFile is absolute, ensure rootDir comparison works correctly in CrawlProject
		// This was handled by using absolute paths internally in CrawlProject
	}

	err = WriteStringToFile(outputPath, outputContent)
	if err != nil {
		return fmt.Errorf("failed to write output file %s: %w", outputPath, err)
	}

	fmt.Printf("Successfully generated LLM context file: %s\n", outputPath)
	fmt.Printf("Included %d files/directories in the context.\n", crawlResult.IncludedCount)
	if crawlResult.ExcludedCount > 0 {
		fmt.Printf("Excluded %d files/directories based on rules.\n", crawlResult.ExcludedCount)
	}
	// --- End of original RunE logic ---
	return nil
}

func init() {
	// Add global flags to rootCmd PersistentFlags
	rootCmd.PersistentFlags().BoolVarP(&verboseFlag, "verbose", "v", false, "Enable verbose logging to stderr")
	rootCmd.PersistentFlags().IntVar(&llmTimeout, "llm-timeout", 120, "Timeout in seconds for LLM API calls")
	// Add other global flags (e.g., --config path, --provider, --model overrides) if desired

	// Flags specific to the root command (context dumping)
	rootCmd.Flags().StringVarP(&outputFile, "output", "o", "llm.txt", "Name of the output file for context dump")
	rootCmd.Flags().StringSliceVarP(&excludes, "exclude", "e", []string{}, "Glob patterns to exclude for context dump")
	rootCmd.Flags().StringSliceVarP(&includes, "include", "i", []string{}, "Glob patterns to include for context dump (overrides excludes)")
	rootCmd.Flags().StringVarP(&targetPath, "path", "p", "", "Only include files/dirs within this path for context dump")
	rootCmd.Flags().IntVarP(&maxDepth, "max-depth", "d", 0, "Max directory depth for context dump (0 for unlimited)")
	rootCmd.Flags().BoolVar(&noGitignore, "no-gitignore", false, "Do not use .gitignore rules for context dump")
	rootCmd.Flags().BoolVar(&noLLMignore, "no-llmignore", false, "Do not use .llmignore rules for context dump")
	rootCmd.Flags().BoolVar(&excludeBinary, "exclude-binary", true, "Attempt to exclude binary files for context dump")
	rootCmd.Flags().BoolVar(&includeHeader, "header", true, "Include a header in the context dump output file")

	// Add the new commit command
	rootCmd.AddCommand(cmd.CommitCmd)

	// Add other commands here later
}

```

---

### File: npm/.npmignore

```npmignore
# Exclude build artifacts
*.o
*.a

# Exclude any potential Go source files
*.go
go.mod
go.sum

# Exclude Node.js development dependencies
node_modules/

# Exclude Git stuff
.git/
.gitignore

# Exclude macOS metadata
.DS_Store

# Exclude any test files
test/
tests/
__tests__/
*.test.js 
```

---

### File: npm/README.md

```md
# üöÄ LLMify

> **A CLI tool that generates a comprehensive text file containing your codebase context for Large Language Models (LLMs)**

[![npm version](https://img.shields.io/npm/v/llmify.svg?style=flat-square)](https://www.npmjs.com/package/llmify)
[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg?style=flat-square)](https://github.com/username/llmify/blob/main/LICENSE)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square)](https://github.com/username/llmify/pulls)

## ‚ú® Features

- üìä **Visual Project Structure** - Crawls project directories and creates a tree structure
- üìÑ **File Content Extraction** - Includes the content of all relevant text files
- üß† **Context Optimization** - Formats output in a way that's optimized for LLM context
- üîç **Intelligent Filtering** - Respects `.gitignore` and `.llmignore` patterns
- üõ†Ô∏è **Highly Customizable** - Control depth, paths, include/exclude patterns

## üì¶ Installation

### Pre-built Binaries

Download the appropriate binary for your platform from the [Releases page](https://github.com/username/llmify/releases).

### Build from Source

```bash
# Clone the repository
git clone https://github.com/username/llmify.git
cd llmify

# Build the binary
go build -o llmify .
# Or on Windows: go build -o llmify.exe .

# Optional: Move to a directory in your PATH
# Linux/macOS
sudo mv llmify /usr/local/bin/
# Or for user-local installation: mv llmify ~/bin/
```

## üöÄ Quick Start

```bash
# Basic usage - creates llm.txt in the current directory
llmify

# Paste into your favorite LLM
cat llm.txt | pbcopy  # macOS
cat llm.txt | xclip   # Linux
type llm.txt | clip   # Windows
```

## üë©‚Äçüíª Usage Examples

```bash
# Specify a different root directory
llmify /path/to/your/project

# Specify a different output file
llmify -o context_for_gpt.txt

# Only include content from a specific subdirectory or file
llmify -p src/components
llmify --path main.go

# Exclude specific patterns
llmify -e "*.log" -e "**/.cache/*"

# Include specific files that would otherwise be excluded
llmify -i "config/important.json"

# Limit directory depth for large projects
llmify -d 3

# Disable .gitignore processing
llmify --no-gitignore

# See detailed output (helpful for debugging)
llmify -v
```

## üîß Using `.llmignore`

Create a `.llmignore` file in your project's root directory to specify patterns that should be excluded from LLM context. This uses the same syntax as `.gitignore`. These rules apply *after* the `--path` filter, if used.

Example `.llmignore`:

```
# Exclude large data files
data/*.csv
*.json.gz

# Exclude generated documentation
docs/generated/

# Exclude specific libraries
lib/external/
```

## üéØ Full CLI Options

```
Usage:
  llmify [directory] [flags]

Flags:
  -e, --exclude strings      Glob patterns to exclude (can be used multiple times)
      --exclude-binary       Attempt to exclude binary files based on content detection (default: true)
      --header               Include a header with project info (default: true)
  -i, --include strings      Glob patterns to include (overrides excludes, use carefully)
  -d, --max-depth int        Maximum directory depth to crawl (0 for unlimited)
      --no-gitignore         Do not use .gitignore rules
      --no-llmignore         Do not use .llmignore rules
  -o, --output string        Name of the output file (default "llm.txt")
  -p, --path string          Only include files/directories within this specific relative path
  -v, --verbose              Enable verbose logging
  -h, --help                 Display help information
```

## üí° Example Output

<details>
<summary>Click to see example output</summary>

```
============================================================
Project Root: /path/to/your/project
Generated At: 2023-06-15T10:30:45Z
============================================================

## File Tree Structure

```
yourproject/
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ utils.go
‚îî‚îÄ‚îÄ docs/
    ‚îú‚îÄ‚îÄ README.md
    ‚îî‚îÄ‚îÄ usage.md
```

============================================================

## File Contents

### File: .gitignore

```
node_modules/
*.log
dist/
```

---

### File: main.go

```go
package main

import (
    "fmt"
)

func main() {
    fmt.Println("Hello, world!")
}
```

---

### File: utils.go

```go
package main

// ... file content here ...
```
```

</details>

## üìù License

MIT License - See LICENSE file for details.

---

<p align="center">
  Made with ‚ù§Ô∏è for better LLM interactions
  <br>
  <a href="https://github.com/username/llmify">Star on GitHub</a>
</p> 


```

---

### File: npm/cli.js

```js
#!/usr/bin/env node

const os = require('os');
const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

// Mapping from Node's process.platform/arch to binary name parts
const platformMapping = {
  'darwin': 'darwin',
  'linux': 'linux',
  'win32': 'windows',
};

const archMapping = {
  'x64': 'amd64',
  'arm64': 'arm64',
};

const platform = os.platform();
const arch = os.arch();

const goPlatform = platformMapping[platform];
const goArch = archMapping[arch];

if (!goPlatform || !goArch) {
  console.error(`Error: Unsupported platform/architecture: ${platform}/${arch}`);
  process.exit(1);
}

let binaryName = `llmify-${goPlatform}-${goArch}`;
if (goPlatform === 'windows') {
  binaryName += '.exe';
}

// __dirname is the directory where this script (cli.js) resides
const binaryPath = path.join(__dirname, 'bin', binaryName);

// Check if the binary exists
if (!fs.existsSync(binaryPath)) {
  console.error(`Error: Could not find the llmify binary for your platform (${platform}/${arch}) at ${binaryPath}`);
  console.error('Please report this issue on GitHub.');
  process.exit(1);
}

// Get arguments passed to the npm script, excluding 'node' and the script path
const args = process.argv.slice(2);

// Run the binary
const child = spawn(binaryPath, args, { stdio: 'inherit' }); // 'inherit' pipes stdin, stdout, stderr

child.on('error', (err) => {
  console.error(`Error executing binary: ${err}`);
  process.exit(1);
});

child.on('exit', (code, signal) => {
  if (signal) {
    // Process terminated by signal
    process.kill(process.pid, signal);
  } else {
    // Process exited normally
    process.exit(code);
  }
}); 
```

---

### File: npm/package.json

```json
{
  "name": "llmify",
  "version": "0.0.7",
  "description": "A CLI tool that generates codebase context for LLMs and provides AI-powered development tools",
  "license": "MIT",
  "author": "Jake <jakezegil@gmail.com>",
  "homepage": "https://github.com/jakezegil/llmify",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jakezegil/llmify.git"
  },
  "bugs": {
    "url": "https://github.com/jakezegil/llmify/issues"
  },
  "keywords": [
    "llm",
    "ai",
    "context",
    "codebase",
    "cli",
    "go",
    "development",
    "tool",
    "git",
    "commit",
    "documentation",
    "openai",
    "anthropic",
    "ollama"
  ],
  "main": "cli.js",
  "bin": {
    "llmify": "./cli.js"
  },
  "files": [
    "bin/",
    "cli.js",
    "README.md"
  ],
  "engines": {
    "node": ">=14"
  },
  "scripts": {
    "build": "echo 'No build required'"
  }
}

```

---

### File: scripts/README.md

```md
# LLMify Build and Deployment Scripts

This directory contains scripts to simplify building, installing, and deploying LLMify.

## Available Scripts

### `build.sh`

Builds LLMify binaries for the current platform and optionally for all supported platforms.

```bash
# Run from the project root
./scripts/build.sh
```

Features:
- Builds a binary for your current platform
- Optionally builds for all supported platforms (Linux, macOS, Windows)
- Embeds version info from git
- Also builds the npm package

### `install.sh`

Installs LLMify to your system (requires a built binary).

```bash
# Run from the project root
./scripts/install.sh
```

Features:
- Automatically detects the best installation location
- Adds LLMify to your PATH
- Supports both user-local and system-wide installation

### `deploy.sh`

Prepares a release and optionally publishes it to GitHub.

```bash
# Run from the project root
./scripts/deploy.sh
```

Features:
- Creates release archives for all platforms
- Updates the changelog
- Creates a git tag
- Can create a GitHub release (requires GitHub CLI)
- Can publish the npm package

### `quickstart.sh`

The easiest way to get started with LLMify - builds and runs in one command.

```bash
# Run from the project root
./scripts/quickstart.sh
```

Features:
- Builds LLMify
- Runs it on a directory of your choice
- Shows a preview of the output

## Making Scripts Executable

Before using these scripts, make them executable:

```bash
# Run from the project root
chmod +x scripts/*.sh
```

## For Windows Users

These scripts are designed for Unix-like systems (Linux, macOS). Windows users can:

1. Use Git Bash or WSL to run these scripts
2. Use the manual build commands from the main README.md
3. Download pre-built binaries from the releases page 
```

---

### File: scripts/build.sh

```sh
#!/bin/bash
set -e

# Build script for LLMify
# This script creates binaries for multiple platforms

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}Building LLMify...${NC}"

# Get current version from git tag or default to development
VERSION=$(git describe --tags --always --abbrev=0 2>/dev/null || echo "dev")
COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
BUILD_TIME=$(date -u '+%Y-%m-%d_%H:%M:%S')

echo -e "${BLUE}Version: ${VERSION}, Commit: ${COMMIT}${NC}"

# Create build directory if it doesn't exist
mkdir -p bin

# Ensure npm/bin directory exists
mkdir -p npm/bin

# Build for the current platform first for quick testing
echo -e "${BLUE}Building for current platform...${NC}"
go build -ldflags "-X main.version=${VERSION} -X main.commit=${COMMIT} -X main.buildTime=${BUILD_TIME}" -o bin/llmify .
echo -e "${GREEN}‚úì Built for current platform${NC}"

# Ask if user wants to build for all platforms
read -p "Build for all platforms? (y/n): " BUILD_ALL

if [[ $BUILD_ALL == "y" ]]; then
    echo -e "${BLUE}Building for all supported platforms...${NC}"
    
    # Define platforms
    PLATFORMS=("linux/amd64" "linux/arm64" "darwin/amd64" "darwin/arm64" "windows/amd64")
    
    for PLATFORM in "${PLATFORMS[@]}"; do
        GOOS=${PLATFORM%/*}
        GOARCH=${PLATFORM#*/}
        OUTPUT_NAME="bin/llmify-${GOOS}-${GOARCH}"
        NPM_OUTPUT_NAME="npm/bin/llmify-${GOOS}-${GOARCH}"
        
        if [ "$GOOS" = "windows" ]; then
            OUTPUT_NAME="${OUTPUT_NAME}.exe"
            NPM_OUTPUT_NAME="${NPM_OUTPUT_NAME}.exe"
        fi
        
        echo -e "${BLUE}Building for ${GOOS}/${GOARCH}...${NC}"
        GOOS=$GOOS GOARCH=$GOARCH go build -ldflags "-X main.version=${VERSION} -X main.commit=${COMMIT} -X main.buildTime=${BUILD_TIME}" -o "${OUTPUT_NAME}" .
        
        # Copy binary to npm/bin directory
        cp "${OUTPUT_NAME}" "${NPM_OUTPUT_NAME}"
        
        echo -e "${GREEN}‚úì Built ${OUTPUT_NAME} and copied to npm/bin${NC}"
    done
fi

# Build the npm CLI wrapper
echo -e "${BLUE}Building npm package...${NC}"
(cd npm && npm install && npm run build)
echo -e "${GREEN}‚úì Built npm package${NC}"

echo -e "${GREEN}Build complete!${NC}"
echo -e "Binaries are available in the ${BLUE}bin/${NC} directory and ${BLUE}npm/bin/${NC} directory" 
```

---

### File: scripts/deploy.sh

```sh
#!/bin/bash
set -e

# Deployment script for LLMify
# This script creates release assets and helps with GitHub releases

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Check for required tools
REQUIRED_TOOLS=("git" "go" "npm" "gh")
for tool in "${REQUIRED_TOOLS[@]}"; do
    if ! command -v "$tool" &> /dev/null; then
        echo -e "${RED}Error: $tool is not installed or not in PATH.${NC}"
        
        if [ "$tool" = "gh" ]; then
            echo -e "The GitHub CLI ($tool) is required for this script."
            echo -e "Install it from: ${BLUE}https://cli.github.com/${NC}"
        fi
        
        exit 1
    fi
done

echo -e "${BLUE}LLMify Deployment Script${NC}"

# Check if we're in the repo root
if [ ! -f "main.go" ] || [ ! -d "npm" ]; then
    echo -e "${RED}Error: This script must be run from the repository root.${NC}"
    exit 1
fi

# Create directories
mkdir -p dist/release
# Ensure npm/bin directory exists
mkdir -p npm/bin

# Check for uncommitted changes
if ! git diff-index --quiet HEAD --; then
    echo -e "${YELLOW}Warning: You have uncommitted changes.${NC}"
    read -p "Continue anyway? (y/n): " CONTINUE
    if [[ $CONTINUE != "y" ]]; then
        echo -e "Exiting."
        exit 0
    fi
fi

# Get or prompt for version
CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
echo -e "Current version: ${GREEN}${CURRENT_VERSION}${NC}"
read -p "New version (leave empty to use current): " NEW_VERSION
VERSION=${NEW_VERSION:-$CURRENT_VERSION}

# Remove 'v' prefix for filenames if present
VERSION_NUM=${VERSION#v}

echo -e "${BLUE}Building release for version: ${VERSION}${NC}"

# Build for all platforms
echo -e "${BLUE}Building binaries for all platforms...${NC}"
PLATFORMS=("linux/amd64" "linux/arm64" "darwin/amd64" "darwin/arm64" "windows/amd64")
for PLATFORM in "${PLATFORMS[@]}"; do
    GOOS=${PLATFORM%/*}
    GOARCH=${PLATFORM#*/}
    BINARY_NAME="llmify"
    ARCHIVE_NAME="llmify-${VERSION_NUM}-${GOOS}-${GOARCH}"
    NPM_BINARY_NAME="npm/bin/llmify-${GOOS}-${GOARCH}"
    
    if [ "$GOOS" = "windows" ]; then
        BINARY_NAME="${BINARY_NAME}.exe"
        ARCHIVE_NAME="${ARCHIVE_NAME}.zip"
        NPM_BINARY_NAME="${NPM_BINARY_NAME}.exe"
    else
        ARCHIVE_NAME="${ARCHIVE_NAME}.tar.gz"
    fi
    
    echo -e "${BLUE}Building for ${GOOS}/${GOARCH}...${NC}"
    GOOS=$GOOS GOARCH=$GOARCH go build -ldflags "-X main.version=${VERSION} -X main.buildTime=$(date -u '+%Y-%m-%d_%H:%M:%S')" -o "dist/release/${BINARY_NAME}" .
    
    # Copy binary to npm/bin directory
    cp "dist/release/${BINARY_NAME}" "${NPM_BINARY_NAME}"
    echo -e "${GREEN}‚úì Copied binary to npm/bin/${NC}"
    
    # Create archive
    pushd dist/release > /dev/null
    
    cp ../../README.md .
    cp ../../LICENSE . 2>/dev/null || echo "No LICENSE file found"
    
    if [ "$GOOS" = "windows" ]; then
        zip -q "${ARCHIVE_NAME}" "${BINARY_NAME}" README.md LICENSE 2>/dev/null
    else
        tar -czf "${ARCHIVE_NAME}" "${BINARY_NAME}" README.md LICENSE 2>/dev/null
    fi
    
    # Remove binary and docs after archiving
    rm "${BINARY_NAME}" README.md LICENSE 2>/dev/null
    
    popd > /dev/null
    
    echo -e "${GREEN}‚úì Created ${ARCHIVE_NAME}${NC}"
done

# Build npm package
echo -e "${BLUE}Building npm package...${NC}"
(cd npm && npm version "$VERSION_NUM" --no-git-tag-version && npm install && npm run build)
echo -e "${GREEN}‚úì Built npm package${NC}"

# Create or update changelog
CHANGELOG_FILE="CHANGELOG.md"
if [ ! -f "$CHANGELOG_FILE" ]; then
    echo "# Changelog" > "$CHANGELOG_FILE"
    echo "" >> "$CHANGELOG_FILE"
fi

echo -e "${BLUE}Updating changelog...${NC}"
# Get git log since the last release tag
LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
if [ -n "$LAST_TAG" ]; then
    CHANGES=$(git log --pretty=format:"- %s" ${LAST_TAG}..HEAD)
else
    CHANGES=$(git log --pretty=format:"- %s")
fi

# Create new changelog section
TEMP_CHANGELOG=$(mktemp)
echo "# Changelog" > "$TEMP_CHANGELOG"
echo "" >> "$TEMP_CHANGELOG"
echo "## ${VERSION} ($(date '+%Y-%m-%d'))" >> "$TEMP_CHANGELOG"
echo "" >> "$TEMP_CHANGELOG"
echo "$CHANGES" >> "$TEMP_CHANGELOG"
echo "" >> "$TEMP_CHANGELOG"
tail -n +2 "$CHANGELOG_FILE" >> "$TEMP_CHANGELOG"
mv "$TEMP_CHANGELOG" "$CHANGELOG_FILE"

echo -e "${GREEN}‚úì Updated changelog${NC}"

# Create GitHub release
echo -e "${BLUE}Do you want to create a GitHub release? (This requires gh CLI)${NC}"
read -p "Create GitHub release? (y/n): " CREATE_RELEASE

if [[ $CREATE_RELEASE == "y" ]]; then
    echo -e "${BLUE}Creating GitHub release...${NC}"
    
    # Create a new tag if it's a new version
    if [ "$NEW_VERSION" != "" ]; then
        git add "$CHANGELOG_FILE" npm/package.json
        git commit -m "Release $VERSION"
        git tag -a "$VERSION" -m "Release $VERSION"
        echo -e "${GREEN}‚úì Created git tag ${VERSION}${NC}"
    fi
    
    # Create release notes from changelog
    RELEASE_NOTES=$(sed -n "/## ${VERSION}/,/## /p" "$CHANGELOG_FILE" | sed '1d;$d')
    
    # Push to GitHub
    echo -e "${BLUE}Pushing changes to GitHub...${NC}"
    git push && git push --tags
    
    # Create GitHub release
    echo -e "${BLUE}Creating GitHub release...${NC}"
    cd dist/release
    gh release create "$VERSION" \
        --title "$VERSION" \
        --notes "$RELEASE_NOTES" \
        *.tar.gz *.zip
    
    echo -e "${GREEN}‚úì Created GitHub release${NC}"
    
    # Publish npm package
    echo -e "${BLUE}Do you want to publish the npm package?${NC}"
    read -p "Publish npm package? (y/n): " PUBLISH_NPM
    
    if [[ $PUBLISH_NPM == "y" ]]; then
        echo -e "${BLUE}Publishing npm package...${NC}"
        (cd ../../npm && npm publish)
        echo -e "${GREEN}‚úì Published npm package${NC}"
    fi
fi

echo -e "\n${GREEN}Deployment preparation complete!${NC}"
echo -e "Release archives are available in ${BLUE}dist/release/${NC}" 
```

---

### File: scripts/install.sh

```sh
#!/bin/bash
set -e

# Installation script for LLMify
# This script installs the LLMify binary to a location in your PATH

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Default installation directory
DEFAULT_INSTALL_DIR="/usr/local/bin"
USER_LOCAL_BIN="$HOME/bin"
USER_LOCAL_BIN_ALTERNATE="$HOME/.local/bin"

echo -e "${BLUE}LLMify Installation Script${NC}"

# Check for binary in bin directory
if [ -f "bin/llmify" ]; then
    BINARY_PATH="bin/llmify"
elif [ -f "./llmify" ]; then
    BINARY_PATH="./llmify"
else
    echo -e "${RED}Error: LLMify binary not found!${NC}"
    echo -e "Please run ${YELLOW}./scripts/build.sh${NC} first or make sure you're in the correct directory."
    exit 1
fi

echo -e "${GREEN}Found binary at:${NC} $BINARY_PATH"

# Determine best installation directory
if [ -d "$DEFAULT_INSTALL_DIR" ] && [ -w "$DEFAULT_INSTALL_DIR" ]; then
    # System-wide installation (if we have permission)
    SUGGESTED_DIR="$DEFAULT_INSTALL_DIR"
elif [ -d "$USER_LOCAL_BIN" ]; then
    # User's ~/bin directory exists
    SUGGESTED_DIR="$USER_LOCAL_BIN"
elif [ -d "$USER_LOCAL_BIN_ALTERNATE" ]; then
    # User's ~/.local/bin directory exists
    SUGGESTED_DIR="$USER_LOCAL_BIN_ALTERNATE"
else
    # Create user's bin directory
    mkdir -p "$USER_LOCAL_BIN"
    SUGGESTED_DIR="$USER_LOCAL_BIN"
    echo -e "${YELLOW}Created directory: ${SUGGESTED_DIR}${NC}"
    echo -e "${YELLOW}You may need to add this to your PATH.${NC}"
fi

# Ask for installation directory
read -p "Install directory [$SUGGESTED_DIR]: " INSTALL_DIR
INSTALL_DIR=${INSTALL_DIR:-$SUGGESTED_DIR}

# Create directory if it doesn't exist
if [ ! -d "$INSTALL_DIR" ]; then
    echo -e "${YELLOW}Directory $INSTALL_DIR doesn't exist. Creating it...${NC}"
    mkdir -p "$INSTALL_DIR"
fi

# Check write permissions
if [ ! -w "$INSTALL_DIR" ]; then
    echo -e "${YELLOW}You don't have write permissions to $INSTALL_DIR${NC}"
    echo -e "Trying with sudo..."
    sudo cp "$BINARY_PATH" "$INSTALL_DIR/llmify"
else
    cp "$BINARY_PATH" "$INSTALL_DIR/llmify"
fi

# Make executable
chmod +x "$INSTALL_DIR/llmify"

echo -e "${GREEN}LLMify installed successfully to ${INSTALL_DIR}/llmify${NC}"

# Check if directory is in PATH
if [[ ":$PATH:" != *":$INSTALL_DIR:"* ]]; then
    echo -e "${YELLOW}Warning: $INSTALL_DIR is not in your PATH!${NC}"
    echo -e "Add the following line to your ~/.bashrc, ~/.zshrc, or equivalent shell configuration file:"
    echo -e "${BLUE}export PATH=\"\$PATH:$INSTALL_DIR\"${NC}"
    echo -e "Then reload your shell configuration with: ${BLUE}source ~/.bashrc${NC} (or equivalent)"
fi

# Verify installation
echo -e "${BLUE}Verifying installation...${NC}"
if command -v "$INSTALL_DIR/llmify" &> /dev/null; then
    echo -e "${GREEN}Installation verified! You can now use 'llmify' command.${NC}"
else
    echo -e "${YELLOW}Could not verify installation. You may need to restart your terminal.${NC}"
fi

echo -e "\n${GREEN}Installation complete!${NC}" 
```

---

### File: scripts/quickstart.sh

```sh
#!/bin/bash
set -e

# Quickstart script for LLMify
# This script builds and runs LLMify with a single command - perfect for first-time users

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${BLUE}LLMify Quickstart${NC}"
echo -e "This script will build and run LLMify in a single command."

# Check if we're in the repo root
if [ ! -f "main.go" ] || [ ! -d "npm" ]; then
    echo -e "${RED}Error: This script must be run from the repository root.${NC}"
    exit 1
fi

# Check for required tools
echo -e "${BLUE}Checking requirements...${NC}"
if ! command -v go &> /dev/null; then
    echo -e "${RED}Error: Go is not installed or not in PATH.${NC}"
    echo -e "Please install Go from: ${BLUE}https://golang.org/dl/${NC}"
    exit 1
fi

# Create binary directory if it doesn't exist
mkdir -p bin

# Build for the current platform
echo -e "${BLUE}Building LLMify...${NC}"
go build -o bin/llmify .
echo -e "${GREEN}‚úì Build successful!${NC}"

# Make executable
chmod +x bin/llmify

# Ask for input directory
echo -e "${BLUE}Which directory would you like to analyze?${NC}"
echo -e "Press Enter to use the current directory (LLMify itself), or specify a different path:"
read -p "Directory: " TARGET_DIR
TARGET_DIR=${TARGET_DIR:-.}

# Ask for output file
echo -e "${BLUE}Where would you like to save the output?${NC}"
echo -e "Press Enter to use the default (llm.txt), or specify a different filename:"
read -p "Output file: " OUTPUT_FILE
OUTPUT_FILE=${OUTPUT_FILE:-llm.txt}

# Run LLMify
echo -e "${BLUE}Running LLMify on ${TARGET_DIR}...${NC}"
./bin/llmify -o "${OUTPUT_FILE}" "${TARGET_DIR}"

# Check if the output file was created
if [ -f "${OUTPUT_FILE}" ]; then
    echo -e "${GREEN}‚úì Success! LLMify output saved to: ${OUTPUT_FILE}${NC}"
    echo -e "File size: $(du -h "${OUTPUT_FILE}" | cut -f1)"
    
    # Show first few lines
    echo -e "${BLUE}Preview:${NC}"
    head -n 10 "${OUTPUT_FILE}"
    echo -e "${YELLOW}... (output truncated) ...${NC}"
    
    echo -e "\n${GREEN}You can now use this file as context for your LLM!${NC}"
else
    echo -e "${RED}Something went wrong. The output file was not created.${NC}"
fi 
```

---

### File: tree.go

```go
package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// GenerateFileTree creates a string representation of the directory structure.
func GenerateFileTree(root string, includeCriteria func(path string, d os.DirEntry) bool, maxDepth int) (string, error) {
	var builder strings.Builder
	absRoot, err := filepath.Abs(root)
	if err != nil {
		return "", fmt.Errorf("getting absolute path for %s: %w", root, err)
	}
	builder.WriteString(fmt.Sprintf("%s/\n", filepath.Base(absRoot))) // Add root dir name

	err = walkTree(absRoot, "", true, &builder, includeCriteria, maxDepth, 0)
	if err != nil {
		return "", err
	}
	return builder.String(), nil
}

func walkTree(
	currentPath string,
	prefix string,
	isRootDir bool, // Flag to handle prefix differently for root's children
	builder *strings.Builder,
	includeCriteria func(path string, d os.DirEntry) bool,
	maxDepth int,
	currentDepth int,
) error {
	if maxDepth > 0 && currentDepth >= maxDepth {
		return nil
	}

	// Read directory entries
	entries, err := os.ReadDir(currentPath)
	if err != nil {
		// Don't fail the whole process, just note the error
		fmt.Fprintf(os.Stderr, "Warning: Cannot read directory %s: %v\n", currentPath, err)
		return nil // Continue walking other parts
	}

	// Filter entries based on include criteria
	filteredEntries := []os.DirEntry{}
	for _, entry := range entries {
		fullPath := filepath.Join(currentPath, entry.Name())
		if includeCriteria(fullPath, entry) {
			filteredEntries = append(filteredEntries, entry)
		}
	}

	// Sort entries: directories first, then files, alphabetically
	sort.Slice(filteredEntries, func(i, j int) bool {
		infoI, errI := filteredEntries[i].Info()
		infoJ, errJ := filteredEntries[j].Info()
		if errI != nil || errJ != nil {
			// Handle error case if needed, maybe sort by name only
			return strings.ToLower(filteredEntries[i].Name()) < strings.ToLower(filteredEntries[j].Name())
		}
		if infoI.IsDir() != infoJ.IsDir() {
			return infoI.IsDir() // Directories first
		}
		return strings.ToLower(infoI.Name()) < strings.ToLower(infoJ.Name()) // Then sort by name
	})

	for i, entry := range filteredEntries {
		isLast := i == len(filteredEntries)-1
		connector := "‚îú‚îÄ‚îÄ "
		childPrefix := "‚îÇ   "
		if isLast {
			connector = "‚îî‚îÄ‚îÄ "
			childPrefix = "    "
		}

		// For the immediate children of the root, don't add the initial prefix
		currentPrefix := prefix
		if isRootDir {
			currentPrefix = ""
		}

		entryPath := filepath.Join(currentPath, entry.Name())

		if entry.IsDir() {
			builder.WriteString(fmt.Sprintf("%s%s%s/\n", currentPrefix, connector, entry.Name()))
			// Recurse into subdirectory
			err := walkTree(entryPath, currentPrefix+childPrefix, false, builder, includeCriteria, maxDepth, currentDepth+1)
			if err != nil {
				// Propagate error up if needed, or log and continue
				fmt.Fprintf(os.Stderr, "Warning: Error walking subdirectory %s: %v\n", entryPath, err)
			}
		} else {
			builder.WriteString(fmt.Sprintf("%s%s%s\n", currentPrefix, connector, entry.Name()))
		}
	}
	return nil
}

```

---

### File: utils.go

```go
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"unicode/utf8"
)

// DefaultBinaryExtensions is a set of common binary file extensions.
// We use a map for quick lookups.
var DefaultBinaryExtensions = map[string]struct{}{
	".png": {}, ".jpg": {}, ".jpeg": {}, ".gif": {}, ".bmp": {}, ".tiff": {}, ".ico": {},
	".pdf": {},
	".mp3": {}, ".wav": {}, ".ogg": {}, ".flac": {},
	".mp4": {}, ".avi": {}, ".mov": {}, ".mkv": {},
	".zip": {}, ".gz": {}, ".tar": {}, ".rar": {}, ".7z": {},
	".exe": {}, ".dll": {}, ".so": {}, ".dylib": {}, ".app": {},
	".o": {}, ".a": {}, ".obj": {},
	".class": {}, ".jar": {},
	".pyc": {}, ".pyo": {},
	".sqlite": {}, ".db": {},
	".woff": {}, ".woff2": {}, ".ttf": {}, ".otf": {}, ".eot": {},
	".DS_Store": {}, // Common macOS file
}

// IsLikelyTextFile checks if a file is likely text-based.
// It focuses on content-based detection by analyzing a small chunk to detect binary indicators.
func IsLikelyTextFile(path string) (bool, error) {
	// We still use extension checks as a fast first pass
	ext := strings.ToLower(filepath.Ext(path))
	if _, isBinaryExt := DefaultBinaryExtensions[ext]; isBinaryExt {
		return false, nil
	}

	// Try reading a small chunk to detect binary content
	file, err := os.Open(path)
	if err != nil {
		// If we can't open it, we probably can't read it anyway
		return false, fmt.Errorf("could not open file %s: %w", path, err)
	}
	defer file.Close()

	// Read a larger chunk (4KB) for more accurate detection
	buffer := make([]byte, 4096)
	n, err := file.Read(buffer)
	if err != nil && err != io.EOF {
		return false, fmt.Errorf("could not read file %s: %w", path, err)
	}

	if n == 0 {
		return true, nil // Empty file is considered text
	}

	chunk := buffer[:n]

	// Check for non-UTF8 sequences
	if !utf8.Valid(chunk) {
		// Before declaring it binary, check if it might be UTF-16 BOM
		if len(chunk) >= 2 {
			if (chunk[0] == 0xFE && chunk[1] == 0xFF) || (chunk[0] == 0xFF && chunk[1] == 0xFE) {
				// Looks like UTF-16, which we won't handle correctly. Treat as binary.
				return false, nil
			}
		}
		return false, nil // Contains invalid UTF-8 sequences
	}

	// Check for excessive null bytes (common in binary files)
	// Allow a very small number for text files with occasional nulls
	nullCount := bytes.Count(chunk, []byte{0})
	if nullCount > 2 { // More than 2 null bytes in first 4KB suggests binary
		return false, nil
	}

	return true, nil
}

// ReadFileContent reads file content as a string, trying UTF-8 then Latin-1.
func ReadFileContent(path string) (string, error) {
	contentBytes, err := os.ReadFile(path)
	if err != nil {
		return "", fmt.Errorf("reading file %s: %w", path, err)
	}

	if utf8.Valid(contentBytes) {
		return string(contentBytes), nil
	}

	// If not valid UTF-8, try Latin-1 (ISO-8859-1) as a fallback
	var latin1Builder strings.Builder
	latin1Builder.Grow(len(contentBytes))
	for _, b := range contentBytes {
		latin1Builder.WriteRune(rune(b))
	}
	// Add a warning comment? Maybe not, let the LLM figure it out.
	// fmt.Fprintf(os.Stderr, "Warning: File %s was not valid UTF-8, read as Latin-1.\n", path)
	return latin1Builder.String(), nil

	// Alternative: Use iconv or a more robust decoding library if needed,
	// but for LLM context, Latin-1 fallback is often sufficient.
}

// WriteStringToFile writes a string to a file, creating directories if needed.
func WriteStringToFile(filePath string, content string) error {
	dir := filepath.Dir(filePath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("creating directory %s: %w", dir, err)
	}
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("creating file %s: %w", filePath, err)
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	_, err = writer.WriteString(content)
	if err != nil {
		return fmt.Errorf("writing to file %s: %w", filePath, err)
	}
	err = writer.Flush()
	if err != nil {
		return fmt.Errorf("flushing file %s: %w", filePath, err)
	}
	return nil
}

```